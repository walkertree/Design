# Design
设计模式 分享事例

##1、工厂模式 —— Easy_factory
###简单的工厂模式
简单工厂模式，通过传入的参数，动态决定了应该创建哪一个产品类，这些类继承自一个父类或者接口。
![Static Factory Method](http://e.hiphotos.baidu.com/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=58763e0dd21b0ef478e5900cbcad3abf/08f790529822720ef04794d97bcb0a46f21fab0c.jpg)
	
何时使用：

1、编译时无法准确预期要创建的对象的类

2、类想让其子类决定在运行时创建什么

3、类有若干辅助类为其子类，而你想将返回哪个子类这一信息局部化 
（NSNumber）


##2、抽象工厂 —— Abstract_factory
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 

####简单工厂和抽象工厂的区别
简单工厂  | 抽象工厂
------------- | -------------
通过类继承创建抽象产品  | 通过对象组合创建抽象产品
创建一种产品  | 创建多系列产品
子类化创建者并重载工厂方法以创建新产品 | 必须修改父类的接口才能支持新的产品

##3、观察者模式 —— Observer

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
####通知和键-值观察的区别
通知  | 键-值观察
------------- | -------------
一个中心对象为所有观察者提供变更通知  | 被观察的对象直接向观察者发送通知
主要从广义上关注程序事件  |绑定于特定对象属性的值

##4、迭代器模式 —— Iterator
提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象的内部表示

####何时使用迭代器模式？
1、需要访问组合对象内容，而又不暴露其内部表示

2、需要通过多种方式遍历组合对象

3、需要提供一个统一的接口，用来遍历各种类型的组合对象

####几种迭代器方式

1、NSEnumerator 
2、基于块的枚举
3、快速枚举
4、内部枚举

##5、装饰模式 —— Decorate
动态地给一个对象添加一些额外的职责。就扩展功能来说，装饰模式比生成子类更加灵活。

####何时使用装饰模式？

1、想要在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。

2、想要扩展一个类的行为，却做不到。类定义可能被隐藏，无法进行子类化；或者，对类的每个行为的扩展，为支持每种功能组合，将产生大量的子类。

3、对类的职责的扩展是可选的。
